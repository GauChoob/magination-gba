# Take vars.csv generated from codenotes_to_csv.py and make a .rascript file

import csv


class Var:
    def __init__(self, name, address, bit, collections, *args):
        self.name = name
        self.address = int(address, 16)
        self.bit = 7 - int(bit)
        self.collections = [collection.strip() for collection in collections.split(';')]
        self.null = False
        if self.name.startswith('UnusedBit'):
            self.null = True
            assert len(self.collections) == 1 and self.collections[0] == ''
        if 'Empty' in self.name:
            assert len(self.collections) == 1 and self.collections[0] == ''

    def definition(self):
        if self.null:
            return ''
        return f'{self.name} = bit{self.bit}(0x{self.address:04X})\n'

    def representation(self):
        if self.null:
            return f'bit{self.bit}(0x{self.address:04X})'
        else:
            return self.name

    def __int__(self):
        return 1


class Bitfield:
    def __init__(self, name, my_vars, all_vars):
        self.name = name
        self.address = my_vars[0].address
        self.bits = [0]*8
        self.my_vars = my_vars
        for var in my_vars:
            self.bits[7 - var.bit] = 1
        self.all_vars = all_vars

    def collect_bits(self):
        return int(''.join(map(str, self.bits)), 2)

    def definition(self):
        ret = f'{self.name}_{self.address:04X} = bitcount(0x{self.address:04X})'
        if sum(self.bits) == 8:
            return ret + '\n'
        return ret + '  // excluding ' + ', '.join([self.all_vars[self.address][i].representation() for i in range(8) if self.bits[i] == 0]) + '\n'

    def representation(self):
        ret = f'{self.name}_{self.address:04X}'
        if sum(self.bits) == 8:
            return ret
        return ret + ' - ' + ' - '.join([self.all_vars[self.address][i].representation() for i in range(8) if self.bits[i] == 0])

    def __repr__(self):
        return (
            f"Bitfield(name='{self.name}', address={self.address}, "
            f"bits={self.bits}, my_vars={self.my_vars})"
        )

    def __int__(self):
        return sum(self.bits)


def validate(vars):
    names = set()
    for address in vars:
        for var in vars[address]:
            if var.name in names:
                print(f'Error: {var.name} appears multiple times in set!')
            names.add(var.name)


def build_collections(vars):
    collection_map = {
        'Naroom': 'Treasure_Naroom',  # Exclude the stool
        'Naroom_Geyser': 'Treasure_NaroomGeyser',
        'Underneath': 'Treasure_Underneath',
        'Underneath_Geyser': 'Treasure_UnderneathGeyser',
        'Cald': 'Treasure_Cald',
        'Cald_Geyser': 'Treasure_CaldGeyser',
        'Shadowhold': 'Treasure_Shadowhold',
        'Orothe': 'Treasure_Orothe',  # Exclude the 3 Algae so the achievement is not missable
        'Orothe_Geyser': 'Treasure_OrotheGeyser',
        'Arderial': 'Treasure_Arderial',
        'Arderial_Geyser': 'Treasure_ArderialGeyser',
        'Feather': 'Treasure_Useless',
        'HldPrisonerTalk': 'HldPrisonerTalks',  # Overworld
        'HldPrisoner': 'HldPrisoners',  # Shadowhold
        'Party': 'PartyPeople',  # PartyGia intentionally excluded as it is a freebie
        'BlastUrn': 'BlastUrns',
    }
    collections = {}
    bitfields = {}
    # Build all the different collections
    for address in vars:
        for var in vars[address]:
            for collection in var.collections:
                if collection in ['', 'Core', 'Stool', 'Algae']:  # Skip these
                    continue
                target = collection_map[collection]
                if target not in collections:
                    collections[target] = {}
                if var.address not in collections[target]:
                    collections[target][var.address] = []
                collections[target][var.address].append(var)

    # Convert collections to bitfields
    for target in collections:
        for address in collections[target]:
            if len(collections[target][address]) > 4:
                bitfield = Bitfield(target, collections[target][address], vars)
                collections[target][address] = [bitfield]
                bitfields[bitfield.address] = bitfield
    return collections, bitfields


def main():
    with open('vars.csv', 'r') as f:
        fr = csv.reader(f, delimiter=',')
        vars = {}
        for row in fr:
            var = Var(*row)
            if var.address not in vars:
                vars[var.address] = []
            vars[var.address].append(var)
        validate(vars)
        collections, bitfields = build_collections(vars)
        with open('temp/var_autogen.rascript', 'w') as f:
            f.write('// Autogenerated by var_to_rascript.py\n')
            for address in vars:
                if address in bitfields:
                    f.write(bitfields[address].definition())
                for var in vars[address]:
                    f.write(var.definition())
            f.write('// End of autogenerated var_to_rascript.py')
            f.write('\n\n')
            f.write('// Autogenerated by var_to_rascript.py\n')
            for collection in collections:
                # Hardcode the extra Script_SaveVar in Treasure_Naroom
                f.write(f'{collection}_Length = {sum([int(var) for address in collections[collection] for var in collections[collection][address]]) + bool(collection == "Treasure_Naroom")}\n')
                f.write(f'{collection} = [\n    ')
                f.write(',\n    '.join([var.representation() for address in collections[collection] for var in collections[collection][address]]))
                if collection == 'Treasure_Naroom':
                    f.write(',\n    Blades_State/Blades_State')  # Hardcode a Script_SaveVar for any non-zero number
                f.write('\n]\n')
            f.write('// End of autogenerated var_to_rascript.py')


if __name__ == '__main__':
    main()
